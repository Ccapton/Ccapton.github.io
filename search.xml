<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[brook-ok服务端配置程序：方便配置、管理brook、shadowsocks服务]]></title>
    <url>%2F2018%2F09%2F11%2Fbrook_ok%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn 项目地址：https://github.com/Ccapton/brook-ok介绍什么是brook?brook 是一款跨平台(Linux/MacOS/Windows/Android/iOS)代理 / Vpn软件（可用于科学上网）点我进入Brook项目 什么是brook-ok?brook-ok : 为了方便管理、开启brook和shadowsocks服务而生的程序 &gt;_&lt; !点我进入brook-ok项目]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>个人作品</tag>
        <tag>python</tag>
        <tag>brook服务端配置程序</tag>
        <tag>科学上网</tag>
        <tag>vps</tag>
        <tag>brook</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网最优方案 ( VPS + Lotsever加速 + ShadowSocks / Brook )]]></title>
    <url>%2F2018%2F08%2F09%2Fscience2%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cnE-mail: 437499914@qq.com、chenweibin1125@foxmail.com我的简书 https://www.jianshu.com/u/df3b46206dc4 前言关于 VPS (Virtual Private Server 虚拟专用服务器) ，搞技术的朋友都不会陌生，这个服务最近今年在国内外都很火热。我这几年科学上网后，个人感觉： 关于购买vpn服务上网 搭建、使用vps来科学上网的性价比似乎远不及买一个vpn服务账号来的高 vpn服务商稳定性不能保证，因为之前买过一些套餐，有时会很慢才能脸上，甚至最后服务商直接跑了。服务供应商如果不能稳定的生存下去，那么你买的服务也随流产 每家vpn服务商提供的客户端都不一样，导致每次换服务商就要下载新的客户端 关于自建vps上网 如果选购的vps带宽不高的话，看youtube视频的速度、清晰度也不如人意 选对一个实惠且稳定的vps供应商很重要，由于不是用于企业服务，仅仅是个人用来科学上网，vps除了高带宽和基本的cpu性能，根本不需要多余的配置 不要选购大品牌vps，因为买的人很多，国外ip流量很大，会被中国政府屏蔽ip! 例如：vultr，虽然vultr的计费方式是按分钟计费，可以重新部署新的系统来实现更换ip的目的，但是我试了很多次，每次分配的ip都无法ping通。于是我放弃了，浪费了精力、时间和金钱 所以选对一个相对冷门又稳定的vps供应商很重要，配合Lotsever加速技术（提高服务器处理网络数据的效率），再搭建ss/brook服务器，客户端就能享受相对稳定、快速的视频观看体验了 1080p直播 选购VPS这里我介绍一个vps供应商 搬瓦工官网 搬瓦工中文介绍目前仅支持安装Linux系统，既然搞技术，Linux是永远绕不过去的话题，大家就用Linux吧 虽然想通过这篇文章推荐给更多的人用这个供应商，但是又怕用的人多了，然后被政府针对封ip。俗话说的人怕出名，猪怕壮，完全能表达我对于搬瓦工这个平台的担忧。只希望大家不用利用vps去做违法的事就行了，一旦染上黑点，这家企业在大陆的活路就会断掉 搬瓦工最低的套餐价格目前是19.99美元/年（折合人民币约140元/年），相信大家完全可以接收这个价格，毕竟没用过谁也不敢保证国外竟然有这么低价格的vps。根据搬瓦工中文介绍 提供的优惠码购买、部署完你想要的vps后，就可以通过ssh进入服务器进行下一步配置了 我的vps后台 Lotsever加速我部署搬瓦工服务器（Ubuntu）已经有10多天了，但是看youtube视频速度很不理想，很多时候只能看480p，稍微提高到720p以上就会卡顿，但是我在github上找到一个加速脚本后，使这个服务器网络传输效率翻了三十几倍（1080p直播图2 连接速度为28894kbps ,而没开加速前大概是300-500kps），完全不虚一些vpn服务的速度！点我打开 Lotsever加速源码地址 （这个Lotsever加速目前仅支持Centos/Debian/Ubuntu）按照其说明配置加速后，就可以进行 shadowsocks/brook 服务端的搭建了 利用Brook程序搭建 shadowsocks、brook 服务端点我打开 Brook源码地址根据你的服务器类型选择下载对应的Brook程序 为方便执行命令，请将下载好的程序统一改名为brook,然后授予执行权限 chmod +x brook 开启brook服务./brook server -l :9999 -p 666 后台运行 nohup ./brook server -l :9999 -p 666 &amp; 其中9999为端口号，666为密码 开启shadowsocks服务默认加密方式 aes-256-cfb ./brook ssserver -l :9999 -p 666 后台运行 nohup ./brook ssserver -l :9999 -p 666 &amp; 其中9999为端口号，666为密码 关闭所有brook进程killall brook 运行客户端下载 如果在服务器开启的是brook服务，那么你必须下载对应的brook客户端，然后填入服务器地址、端口，密码进行连接 如果开启的是shadowsocks服务，那么可以用brook客户端、或者支持shadowsocks技术的客户端进行连接。 点我打开 Brook客户端 下载页面 点我打开 Shadowsocks Windows 下载页面 点我打开 Shadowsocks Android 下载页面 点我打开 Shadowsocks 苹果（Mac）下载页面 Shadowsocks IOS客户端请用国外appleid登录appstore,搜索shadowsocks并下载 运行这里以Mac端为例 运行brook 运行shadowsocks 服务器配置页 其他环境的客户端配置大同小异，这里不多介绍了，大家请自行百度吧。 关于在Windows10运行brook的情况 在Windows10下，若brook连接后无法科学上网的，请以兼容模式下运行brook - 右击brook主程序 - 点击属性 - 点击兼容性 - 选择windows7兼容模式 - 保存配置后重连就能科学上网了 后记这次的分享不易，我一直在努力尝试怎样以最便宜最实用的方式翻墙上网，最后终于达到自己想要的效果了，希望看到这篇文章的朋友们进行科学上网能少走弯路吧。在油管上，我看到有人用墙改路由器上网的，很厉害的样子，不用一个个客户端配置，连上这个路由的所有设备都能科学上网，也有人用小米路由器刷入开发版，然后ssh进入系统安装ss客户端,也能达到同样的效果！看有没机会自己也来弄弄吧，就这样，byebye]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>VPS</tag>
        <tag>ShadowSocks</tag>
        <tag>Brook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python抓包、爬取裡蕃收藏夹（移动app）数据，整理成API]]></title>
    <url>%2F2018%2F08%2F04%2Flifan%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn 岛国裡蕃Api岛国裡蕃api数据展示数据来源:裡蕃收藏夹 裡蕃收藏夹app截图： 自建web站点截图： 本来看看最近的新番的，又重新下载了裡蕃收藏夹，后来发现，它居然直接用webview承载所有页面数据了。于是便抓了一下包，便是发现了一个很好的爬虫练手机会，加上自己用过flask，便把它的数据呈现出来了 项目地址https://github.com/Ccapton/python-stuff/tree/master/lifan 技术要点 Charles抓包手机网络数据，获取关键用户cookie 携带cookie利用requests获取数据 beautifulsoup解析数据 peewee微型数据库保存数据 flask建立微型web服务器、展示网页站点 flask-restful输出json数据 具体细节就请各位到这个项目源码查看了，相信你们都能读懂全部内容]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>个人作品</tag>
        <tag>Python</tag>
        <tag>Python爬虫</tag>
        <tag>老司机</tag>
        <tag>裡蕃</tag>
        <tag>福利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python打造一个基于socket的文件（夹）传输系统]]></title>
    <url>%2F2018%2F07%2F30%2Ffiletransporter%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn 前言这段时间在学习python，接触到了网络编程中的socket这块，加上自己在用的Linux服务器都是原生支持python的，于是乎有了个做文件传输功能程序的想法。毕竟python语言中，有下载功能的框架一抓一大把，但是主机与主机间快速搭建文件（夹）传输通道的程序似乎不常见，因为我刚接触python不久，有但是我不知道也不奇怪，总得来说，自己做一个练手，成就感满满。 项目地址https://github.com/Ccapton/python-stuff/tree/master/filetransporter 实操预览 思维导图以上思维导图仅供参考，毕竟表达能力有限，具体功能要追究到代码处才能分析其原理。 原理基于socket的通信，相信会编程的朋友都不陌生，而通过socket来传输文件也是很常见的，但是这仅仅是对于单个文件来说很容易实现。如果是多文件呢？我在实现本系统之前尝试了几次，用单一socket通道来传输多文件不切实际，因为调用socket.recv()方法的时候，返回的数据格式是原始数据str类型，要分割不同文件的数据有很大难度。 因为涉及到接收、发送方两端文件数据接收和发送进度的统一性，就要用另外的指令来控制传输工作不乱套，于是我想到多开一个socket作为传输指令的通道，这样指令和数据就分离了，也就容易控制传输工作了！所以有了指令线程和数据线程之分。 要实现传输整个文件夹，首先要遍历这个文件夹，把在其内的所有文件结构准确无误的还原出来；因为是通过一个socket通过传输数据，所以传输文件只能一个接一个来，这样，文件的遍历工作只能等前一个文件传输完毕后才能继续进行，于是又要对遍历工作设计一番。经过改造，我在文件查找（遍历）器内加入了while循环体和供外界继承的回调类，这样就能达到我想要的文件通过socket按顺序传输的效果了。文件查找器FileFinder（阻塞型）源码： import os,time # 文件、文件夹寻找类 (阻塞型) # 阻塞的设计： 为了等待调用者的耗时操作【否则很快就完成了文件的遍历任务，调用者达不到顺序操作文件(夹)的意图】 class FileFinder: def __init__(self,finderCallback): self.finderCallback = finderCallback # 文件（夹）路径下所有文件的总大小 self.sum_size = 0 # 调用者控制的参数，若为False,则遍历工作继续进行，若为True，则阻塞任务，等待调用者完成它的其他耗时操作后在考虑是否改变此值 self.recycle = True # 调用者控制的参数，若为False,则正常工作，若为True，则当recycle为False时遍历工作不阻塞快速完成，recycle为True时遍历工作阻塞 self.off = False # 文件（夹）找到时的回调类 class FinderCallback: # 找到文件夹 def onFindDir(self,dir_path): pass # 找到文件 def onFindFile(self,file_path,size): pass # 预留的刷新函数 def onRefresh(self): pass # 查找文件（夹）方法 def list_flie(self,root_dir): if os.path.isfile(root_dir): while self.recycle: time.sleep(0.05) if self.finderCallback: self.finderCallback.onFindFile(root_dir,os.path.getsize(root_dir)) self.finderCallback.onRefresh() if not self.off: self.recycle = True else: dirlist = os.listdir(root_dir) # 列出文件夹下所有的目录与文件 for dir in dirlist: path = os.path.join(root_dir, dir) if os.path.isfile(path): while self.recycle: time.sleep(0.05) if self.finderCallback: self.finderCallback.onFindFile(path,os.path.getsize(path)) self.finderCallback.onRefresh() if not self.off: self.recycle = True else: while self.recycle: time.sleep(0.05) if self.finderCallback: self.finderCallback.onFindDir(path) self.finderCallback.onRefresh() if not self.off: self.recycle = True # 递归调用（当遍历到文件夹时，继续遍历，直到当前文件夹下没有文件夹为止） self.list_flie(path) 通过继承FileFinder的回调类FinderCallback，重写其 onFindDir(self,dir_path) 和onFindFile(self,file_path,size)方法，在这两个方法里面发送相关指令到接收端。 但最难的就是两端的指令线程内的socket指令信息的处理，这需要深入代码去具体研究，本人能力有限，也就不细说了。需要研究一番的朋友，请移步该项目地址 https://github.com/Ccapton/python-stuff/tree/master/filetransporter 注意运行接收端程序，需要一个能访问的地址，也即是说最好是局域网内进行文件传输工作，因为局域网本地ip都是可以直接访问的，若是在公共网络传输文件，必须知道接收方主机的公网ip。如果用的是vps或者虚拟主机，请务必检查安全组配置，需开放9997、9998两个端口]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>个人作品</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于cocos2d-x引擎的角色控制器]]></title>
    <url>%2F2018%2F06%2F20%2Frolecontroller%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn 最近开始学习cocos2d-x引擎，用来做一些2d小游戏。在基本做完一个飞机大战游戏的情况下，感觉手机玩沙盒2d游戏需要一个控制角色移动的控制手柄，不然光靠点屏幕是不精确而又费劲的体验。于是开始写了一个角色控制器RoleController，效果如下项目地址https://github.com/Ccapton/Cocos2d-x-RoleController 演示程序apkhttps://raw.githubusercontent.com/Ccapton/Cocos2d-x-RoleController/master/Fightman-debug.apk RoleController.h内容 #ifndef __ROLE_CONTROLLER_H__ #define __ROLE_CONTROLLER_H__ #include &quot;cocos2d.h&quot; USING_NS_CC; #include &quot;string&quot; class RoleControllerListenr { public: // velocity 为控制球相对于控制中心的偏移量， // 你可以在具体的实现方法内利用定时更新函数对此结果进行利用，进而实现对精灵的位置控制 virtual void onControllerTouchBegan(Vec2 velocity) = 0; virtual void onControllerTouchMoving(Vec2 velocity) = 0; virtual void onControllerTouchEnded(Vec2 velocity) = 0; }; class RoleController : public Layer { private: RoleController() {} public: bool touchIngInside = false; float radius = 0; float ball_d_bg = 0; Vec2 offset; Color4F bg_color = Color4F(-1.0f,-1.0f,-1.0f,-1.0f); Color4F ball_color = Color4F(-1.0f, -1.0f, -1.0f, -1.0f);; Node * tempLayer; Node * tempLayer2; std::string bg_resouce_path; std::string ball_resouce_path; static RoleController* createController(float radius,const Vec2 offset); RoleControllerListenr * listener; virtual bool init(); void createBg(); void createBall(); void setPositioin(Vec2 position); void setOffset(Vec2 offset); void setBgResoucePath(std::string path); void setBallResoucePath(std::string path); bool touchBeganCallback(Touch* touch, Event* event); void touchMovedCallback(Touch* touch, Event* event); void touchEndedCallback(Touch* touch, Event* event); void setRoleControllerListenr(RoleControllerListenr * listener); CREATE_FUNC(RoleController); }; #endif 本来想把它做完再发文章的，但是觉得没什么人看我的文章，也就算了，毕竟这个控制器挺简单的。 原理主要是靠触摸事件来判断手指位置来判断是否其在控制器内，若是则使小圆的位置跟随触摸移动。若一开始触摸从控制器内，然后往外移动最后离开控制器范围，则小球则会在控制内移动然后根据手指落点的位置而在控制器的圆边界上移动。这个控制器最复杂的地方是： 计算这个小球在控制器边界移动的坐标，最后解决了这个算法，一个简单的控制器变完成了9成。.通过高中数学的解析几何知识 我得到了下面这个算法： // 控制器小球在控制器边界圆上移动时，其坐标的算法 // targetX,targetY为所求圆边界上的坐标 （这是仅有的两个未知量） // centerP.x为控制器中心横坐标，centerP.y为控制器中心纵坐标 // touchP.x为触控点横坐标，touchP.y为触控点纵坐标 // distance 为触控点距离控制器中心的距离，radius则是圆形控制器的半径 float targetX = 0, targetY = 0; if (touchP.x &gt; centerP.x &amp;&amp; touchP.y &gt; centerP.y) { targetX = centerP.x + radius * (touchP.x - centerP.x) / distance; targetY = centerP.y + radius * (touchP.y - centerP.y) / distance; }else if (touchP.x &lt; centerP.x &amp;&amp; touchP.y &gt; centerP.y) { targetX = centerP.x - radius * (centerP.x - touchP.x) / distance; targetY = centerP.y + radius * (touchP.y - centerP.y) / distance; }else if (touchP.x &lt; centerP.x &amp;&amp; touchP.y &lt; centerP.y) { targetX = centerP.x - radius * (centerP.x - touchP.x) / distance; targetY = centerP.y - radius * (centerP.y - touchP.y) / distance; }else if (touchP.x &gt; centerP.x &amp;&amp; touchP.y &lt; centerP.y) { targetX = centerP.x + radius * (touchP.x - centerP.x) / distance; targetY = centerP.y - radius * (centerP.y - touchP.y ) / distance; } 最后便是回调结果了，将小球相对于控制器中心的偏移量Vec2传递出去，这里用到了RoleControllerListenr这个类作为接口，你需要在合适的地方继承此接口类并实现其抽象函数 class RoleControllerListenr { public: // velocity 为控制球相对于控制中心的偏移量， // 你可以在具体的实现方法内利用定时更新函数对此结果进行利用，进而实现对精灵的位置控制 virtual void onControllerTouchBegan(Vec2 velocity) = 0; // 开始触摸控制器 virtual void onControllerTouchMoving(Vec2 velocity) = 0; // 控制器小球移动中 virtual void onControllerTouchEnded(Vec2 velocity) = 0; // 结束触摸控制器 }; 后记很多人估计看到这一头雾水，这里很多的代码是基于cocos2dx这个游戏开发引擎的，看不懂很正常，对游戏开发感兴趣的朋友可以去官网仔细阅读一下文档。好了，关于这个控制器就介绍到这了，希望你们会喜欢。别忘了关注我，给我星星https://github.com/Ccapton]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>Cocos2d-x</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用自建国外服务器开启专属于自己的VPN服务(brook框架)，翻墙上网速度快到飞起！]]></title>
    <url>%2F2018%2F04%2F09%2Fscience%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cnE-mail: 437499914@qq.com、chenweibin1125@foxmail.com我的简书 https://www.jianshu.com/u/df3b46206dc4 一、前言之前科学上网时，一直是买一些vpn提供商的服务，但是性价比非常低。因为自己不是天天翻墙查资料、看youtube视频，每个月10-20块的支出感觉有点多余，加上他们的速度简直不敢恭维，卡的不行。后来找了一个免费的vpn平台，还是因为它的速度，让我提不起兴趣每次上网的时候去开启软件，因为一旦开启的vpn，浏览国内的ip内容就会很慢。终于前两天在逛今日头条的时候看到一个关于自建谷歌服务器（国外ip的服务器）科学上网的视频(这段视频很快被今日头条官方和谐掉了2333，还好我眼疾手快，很快就明白了之中的原理)，加上我对Linux服务器的理解，很快就搭建了一个外服的vpn服务系统，现在能通过各平台客户端连接到vpn服务器并科学上网了，速度简直出乎所有人意料的快，令我非常满意。现在特地写出这篇博文给小伙伴们分享一下，让你们体验从所未有的科学冲浪！ Youtube的1080p视频拖放 二、原理这个vpn的根本原理是：一个境外ip的服务器转发国内客户端的网络请求，即服务器充当一个路由器的功能，所有境外ip的内容都会经由服务器返回给对应客户端 三、私人VPN搭建概要 搭建一个境外的Linux服务器(我搭建的是Ubuntu，因为Ubuntu集成了很多常用的指令集合) 通过ssh访问Linux服务器，在Linux服务器内搭建VPN服务（brook框架），这里需要提前安装Go语言的环境（brook服务器框架是go语音写的） 客户端（Windows ,Mac ,Android ,Ios）填写Linux服务器的公共ipv4地址、端口 ，密码访问Linux服务器的vpn服务。这样就可以科学上网了 搭建服务器，说实话，如果一点基础知识都没有的话，弄起来确实有点懵，不过用过国内的云服务（阿里云，腾讯云，京东云的云主机服务）的朋友就很容易上手了，因为这些东西都是大同小异的。 国内的dns服务器会屏蔽掉谷歌、youtube等很多公司的内容服务ip，但他们提供给个人用户的云服务器ip不会被屏蔽） 四、代码材料 Go语言环境搭建教程 http://www.runoob.com/go/go-environment.html brook框架 https://github.com/txthinking/brook (请仔细阅读此框架的文档) 1、brook服务器 https://github.com/txthinking/brook/releases/download/v20180401/brook （根据你的服务器内核在github说明页选择对应版本） 2、brook客户端 （Android客户端为例，可按照需要选择相应的平台）https://github.com/txthinking/brook/releases/download/v20180401/Brook.apk 五、具体步骤1、搭建服务器： 这里我选择了亚马逊的云服务器，因为他们有一年云服务免费使用的福利套餐！！！（谷歌云也是免费一年，还有300美元的云服务消费额度） （1）首先用你的邮箱注册一个亚马逊云服务的账号（最好不要用QQ邮箱，很有可能收不到验证邮件！），我用的是Foxmail，这也是腾讯的邮箱（和QQ邮箱绑定的），你们可以用网易邮箱。登录你的控制台，然后填写一个很重要的支付账号，需要提供一个信用卡信息。如果你有信用卡，就如实填写，没有就去淘宝买一个虚拟的visa卡（8块左右）（提前和淘宝客户沟通买虚拟Visa的用途，他提供卡号，过期日期），然后按照下图操作： 关于美国公民的用户信息格式可以参考 http://www.haoweichi.com/ （里面的信用卡都是没用的，我只是给你看地址和邮编的对应格式） 填写完支付账号后，就等个几小时（上面写一天内会验证完，实际很快，我的不用一小时就验证完了），等系统验证信用卡真实后就可以进入控制台生成云服务器了 （2）搭建亚马逊Linux服务器(EC2)教程 https://jingyan.baidu.com/article/0eb457e5d7848403f0a90545.html 2、搭建代码环境 (需要了解 指令 cd 、wget ) （1）通过ssh登录Linux服务器（控制台有教程） （2）先搭建go语言环境 http://www.runoob.com/go/go-environment.html (如果出现权限报错，请在指令前加 sudo 再执行，下载文件的指令的格式为： wget 文件地址) （3）下载brook服务器 https://github.com/txthinking/brook/releases/download/v20180401/brook （根据你的服务器内核在github说明页选择对应版本） wget https://github.com/txthinking/brook/releases/download/v20180401/brook 3、运行brook服务器 先改变brook文件执行权限 chmod +x brook 开跑程序！！！ 前台模式 ./brook server -l :9999 -p 6666 后台模式 nohup ./brook server -l :9999 -p 6666 &amp; (ps：9999是端口号，6666是你要设定的密码，这两个都可以修改) 前台模式下：CTRL+C 退出brook程序后台模式下：先 CTRL+C 后 killall brook 退出brook程序brook服务器的具体操作请阅读源码说明 https://github.com/txthinking/brook/wiki/How-to-run-Brook-Server-on-Linux%3F (如果下载brook时，你更改了brook的保存路径，就用 cd 指令更改当前目录为brook文件的目录路径) 4、客户端brook连接到vpn（android为例） 下载 https://github.com/txthinking/brook/releases/download/v20180401/Brook.apk 六、后记到此，这个vpn系统就弄好了！非常快的科学上网体验，你值得拥有！本来想在简书和csdn上发这篇文章的，但是最近国家打击vpn软件非常严厉，关于翻墙，科学上网的文章教程一律不得发布、转载了。所以就写在我的博客里吧希望有缘人看到这篇文章就多来我的博客、简书、github留言哈！有什么问题不懂的也可以邮件联系我 E-mail: 437499914@qq.com、chenweibin1125@foxmail.com 好吧，祝各位工作顺利、生活愉快！ 我的github https://github.com/Ccapton我的简书 https://www.jianshu.com/u/df3b46206dc4]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
        <tag>vpn</tag>
        <tag>免费翻墙</tag>
        <tag>亚马逊云主机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用Bmob云后端云函数实现移动应用与数据库的数据交互]]></title>
    <url>%2F2018%2F01%2F24%2Fbmob_cloud_function%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cnE-mail: 437499914@qq.com、chenweibin1125@foxmail.com 一、前言由于自己没有专心研究后端技术，很多与数据库打交道的工作让我这个菜鸟弄起来很麻烦，之前做android应用用到自己的独立数据都是寄托于bmob云后端平台，但是一直调用的是它集成在android端的sdk代码来实现数据库数据的更新与获取。这段时间突然想到这个调用sdk代码的方式真的是太僵硬了，而且把大量原本应该自由变更的逻辑写死在了移动应用内，以后业务需求变了就只能更新app了。所以用云函数进行app数据交互是一个对于移动端开发者获取、更新数据的最佳方式吧。 图中被涂掉的部分是你的bmob应用的Secret Key。 二、如何调用云函数通过查看官方的教程，我们发现有多种途径android，iOS，Restful, C# , Javascript, php, web都可以调用云函数，根据不同的平台我们可以选择对应平台的sdk代码调用云函数，不过我今天写这篇文章的目的是为了展示最通用最自由来获取数据的方式，所以用的是 直接用访问http的方式 云函数的http调用的url拼接规则为1. GET方式http://cloud.bmob.cn/{Secret Key}/{云函数名}?{参数名}={值}&amp;{参数名}={值}… get方式可在浏览器直接输入地址和参数查看数据，测试的时候用get很直观，但是为了安全起见还是用post方式吧 2. POST方式需要在你的应用内编写相关POST代码(主要是把参数体添加到云函数所在的url例如 http://cloud.bmob.cn/{Secret Key}/{云函数名}) (ps:大括号 { } 不要写上去，括号里的内容才是你要替换的)调用方式就写到这里，不懂的朋友可以联系我 (我也是看bmob文档的) 三、如何写云函数官方教程 http://doc.bmob.cn/cloud_function/web/develop_doc/ 1.首先先创建一个自定义的云函数 2.命名这个函数，并确认这样一个空的云函数就部署好了， 3.了解云函数结构空的云函数如下所示 function onRequest(request, response, modules) { // 云函数包括三大参数 request, response, modules // request 对象包含请求体的所有信息和操作 // response 对象包含返回体的所有信息和操作 // modules 是Bmob云函数提供给大家的各种对象处理的模块 /*包括数据库对象（oData）、文件对象（oFile）、地理位置对象 （oLocation）、关联关系对象（oRelation）、原子操作对象（oAtom）、 数据批量操作对象（oBatch）、数组对象（oArray）、消息推送对象（oPush）、 云函数对象（oFunctions）、HTTP对象（oHttp）、字符编码转换对象（oEncodeing）、 事件对象（oEvent）、bql对象（oBql）、html元素解析对象（oHtmlparser）、 加密对象（oCrypto）。 */ /* 示例： //获取数据库对象 var db = modules.oData; //下面进行其他操作 */ } 我对于云函数的介绍就这么多，很多内容我也是刚接触，不懂的朋友都去看文档，看文档，看文档(重要的事情说三遍)。 ####4 .示例云函数代码(自己写的登录模块) function onRequest(request, response, modules) { var httptype = request.method; var username_get = request.query.username; var password_get = request.query.password; var userinfo_get = request.query.userinfo; var username_post = request.body.username; var password_post = request.body.password; var userinfo_post = request.body.userinfo; var username; var password; var userinfo; if (&quot;GET&quot; == httptype) { //采用get方式调用云函数 username = username_get; password = password_get; userinfo = userinfo_get; }else{ //采用post方式调用云函数 username = username_post; password = password_post; userinfo = username_post; } var db = modules.oData; if(username === &quot;&quot; || username === null ){ response.send(&quot;用户名不能为空&quot;); } else if(password === &quot;&quot; || password === null){ response.send(&quot;密码不能为空&quot;); }else{ db.userSignUp({ &quot;data&quot;:{&quot;username&quot;:username,&quot;password&quot;:password} //用户注册的信息，格式为JSON },function(err,data){ response.send(data);//回调函数 if(data){ var dataObject = JSON.parse(data); if(dataObject.error == null){ //需要设置登录之后获取的sessionToken头信息 db.setHeader({&quot;X-Bmob-Session-Token&quot;:dataObject.sessionToken}); db.updateUserByObjectId({&quot;objectId&quot;:dataObject.objectId ,data:JSON.parse(userinfo)},function(err,data){ response.send(&quot;更新成功&quot;); }) }else{ response.send(&quot;找不到该用户！&quot;); } }else{ response.send(err); } }); } } 四、通过android调用云函数(访问http方式) android端更新用户信息，关键代码源码 https://github.com/Ccapton/BaseApp网路请求框架我用的是okgo库(okhttp封装库 https://github.com/jeasonlzy/okhttp-OkGo) binding.update.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String url = getString(R.string.bmob_function_base_url) + getString(R.string.bmob_function_update); JSONObject jsonObject = new JSONObject(); try { jsonObject.put(&quot;face&quot;,binding.face.getText().toString()); jsonObject.put(&quot;birthday&quot;,binding.birthday.getText().toString()); } catch (JSONException e) { e.printStackTrace(); } OkGo.&lt;String&gt;post(url) .tag(UpdateFragment.this.getActivity()) .params(&quot;username&quot;,binding.phone.getText().toString()) .params(&quot;password&quot;,binding.psw.getText().toString()) .params(&quot;userinfo&quot;,jsonObject.toString()) .execute(new StringCallback() { @Override public void onSuccess(Response&lt;String&gt; response) { System.out.println(&quot;UpdateFragment.onSuccess&quot;); ToastUtils.showShort(response.body()); } }); } }); 五、后记昨天我也是刚刚写完三个云函数：注册、登录、更新信息，感觉很不错，所以才有写这篇文章的动机。目前云函数功能在bmob应用创建前40天免费，之后要收费了，要商用的小伙伴要注意续费呦，现在云函数的使用价格是50元/月。 好吧，祝各位工作顺利、生活愉快！欢迎访问我的github https://github.com/Ccaptonandroid端测试项目 https://github.com/Ccapton/BaseApp]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android</tag>
        <tag>云函数</tag>
        <tag>bmob云后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 一天时间撸一个文件(路径)选择器FileChooser]]></title>
    <url>%2F2018%2F01%2F18%2FFileChooser%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn 前言额，突然心血来潮，把这个功能给做出来了。之前一直以为要一次遍历手机的所有文件再显示出来，后来仔细想了会，没那么复杂，只需要先指定一个路径再获取其子目录，即可完成我想要的效果。 效果 传送门https://github.com/Ccapton/FileChooser 项目结构 FileChooser、FileChooserActivity、FileTourController 这三个类实现界面与文件列表展示逻辑的耦合与内聚。 不过，因为我用到了databinding框架和vectorDrawable文件，所以要在app的build.gradle中如下图绿色框配置代码。 FileChooser.javapackage com.capton.fc; import android.app.Activity; import android.content.Context; import android.content.Intent; import android.support.v4.app.Fragment; /** * Created by capton on 2018/1/5. */ public class FileChooser { private Context mContext; private int themeColorRes = R.color.themeColor; private FileChoosenListener fileChoosenListener; private String mChoosenFilePath = &quot;&quot;; private String title = &quot;选择目标&quot;; private String doneText = &quot;完成&quot;; private int backIconRes = R.drawable.back_white; private boolean showFile = true; public boolean isFileShow() { return showFile; } public FileChooser showFile(boolean showFile) { this.showFile = showFile; return this; } public FileChooser setCurrentPath(String currentPath){ this.mChoosenFilePath = currentPath; return this; } public FileChooser setTitle(String title){ this.title = title; return this; } public FileChooser setDoneText(String doneText) { this.doneText = doneText; return this; } public FileChooser setBackIconRes(int backIconRes) { this.backIconRes = backIconRes; return this; } public FileChooser(Fragment fragment , FileChoosenListener fileChoosenListener) { this.mContext = fragment.getContext(); this.fileChoosenListener = fileChoosenListener; } public FileChooser(Activity activity ,FileChoosenListener fileChoosenListener) { this.mContext = activity; this.fileChoosenListener = fileChoosenListener; } public void open(){ FileChooserActivity.mFileChooser = this; Intent intent = new Intent(mContext,FileChooserActivity.class); intent.putExtra(&quot;themeColorRes&quot;,this.themeColorRes); intent.putExtra(&quot;currentPath&quot;,this.mChoosenFilePath); intent.putExtra(&quot;title&quot;,this.title); intent.putExtra(&quot;doneText&quot;,this.doneText); intent.putExtra(&quot;backIconRes&quot;,this.backIconRes); intent.putExtra(&quot;showFile&quot;,this.showFile); this.mContext.startActivity(intent); } protected void finish(String filePath){ if(fileChoosenListener != null) fileChoosenListener.onFileChoosen(filePath); } public FileChooser setThemeColor(int themeColorRes){ this.themeColorRes = themeColorRes; return this; } public FileChooser setFileChoosenListener(FileChoosenListener fileChoosenListener) { this.fileChoosenListener = fileChoosenListener; return this; } public interface FileChoosenListener{ void onFileChoosen(String filePath); } } FileChooserActivity.javapackage com.capton.fc; import android.os.Bundle; import android.support.v7.widget.LinearLayoutManager; import android.support.v7.widget.ListPopupWindow; import android.view.View; import android.widget.AdapterView; import com.blankj.utilcode.util.Utils; import com.capton.fc.databinding.ActivityFileChooserBinding; import java.io.File; import java.util.ArrayList; import java.util.List; public class FileChooserActivity extends BaseActivity&lt;ActivityFileChooserBinding&gt; { private int themeColorRes; private int backIconRes; private boolean showFile = true; public static FileChooser mFileChooser; private String mChoosenFilePath; private FileTourController tourController; private FileAdapter adapter; private CurrentFileAdapter currentFileAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Utils.init(getApplication()); resetThemeColor(); resetBackIconRes(); setMiddleTitle(); setDoneText(); setShowRightText(true); baseBinding.back.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { FileChooserActivity.this.finish(); } }); } private void setMiddleTitle(){ String middleTitle = getIntent().getStringExtra(&quot;title&quot;); setTitle(middleTitle); } private void setDoneText(){ String doneText = getIntent().getStringExtra(&quot;doneText&quot;); setRightText(doneText); } private void resetThemeColor() { this.themeColorRes = getIntent().getIntExtra(&quot;themeColorRes&quot;,R.color.themeColor); setThemeColor(themeColorRes); } private void resetBackIconRes(){ this.backIconRes = getIntent().getIntExtra(&quot;backIconRes&quot;,R.drawable.back_white); setBackIcon(backIconRes); } @Override public String[] getPermissions() { return requestPermissions; } @Override public int getLayoutId() { return R.layout.activity_file_chooser; } @Override public void setClickListener() { this.showFile = getIntent().getBooleanExtra(&quot;showFile&quot;,true); this.mChoosenFilePath =getIntent().getStringExtra(&quot;currentPath&quot;); tourController = new FileTourController(this,mChoosenFilePath); tourController.setShowFile(this.showFile); adapter = new FileAdapter(this, (ArrayList&lt;FileInfo&gt;) tourController.getCurrenFileInfoList(),R.layout.item_file); binding.fileRv.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false)); binding.fileRv.setAdapter(adapter); currentFileAdapter = new CurrentFileAdapter(this, (ArrayList&lt;File&gt;) tourController.getCurrentFolderList(),R.layout.item_current_file); binding.currentPath.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.HORIZONTAL,false)); binding.currentPath.setAdapter(currentFileAdapter); binding.currentPath.scrollToPosition(tourController.getCurrentFolderList().size()-1); adapter.setItemClickListener(new CommonAdapter.OnItemClickListener() { @Override public void onItemClick(View view, int position) { File selectFile =new File(tourController.getCurrenFileInfoList().get(position).getFilePath()); ArrayList&lt;FileInfo&gt; childFileInfoList = (ArrayList&lt;FileInfo&gt;) tourController.addCurrentFile(selectFile); adapter.setData(childFileInfoList); adapter.notifyDataSetChanged(); currentFileAdapter.setData(tourController.getCurrentFolderList()); currentFileAdapter.notifyDataSetChanged(); binding.currentPath.scrollToPosition(tourController.getCurrentFolderList().size()-1); } }); currentFileAdapter.setItemClickListener(new CommonAdapter.OnItemClickListener() { @Override public void onItemClick(View view, int position) { List&lt;FileInfo&gt; fileInfoList = tourController.resetCurrentFile(position); adapter.setData(fileInfoList); adapter.notifyDataSetChanged(); currentFileAdapter.setData(tourController.getCurrentFolderList()); currentFileAdapter.notifyDataSetChanged(); binding.currentPath.scrollToPosition(tourController.getCurrentFolderList().size()-1); } }); binding.switchSdcard.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { final ListPopupWindow listPopupWindow= new ListPopupWindow(FileChooserActivity.this); listPopupWindow.setAnchorView(v); ArrayList&lt;String&gt; sdcardList = new ArrayList&lt;&gt;(); sdcardList.add(&quot;手机存储&quot;); if(FileTourController.getStoragePath(FileChooserActivity.this,true) != null) sdcardList.add(&quot;SD卡&quot;); SdCardAdapter sdCardAdapter = new SdCardAdapter(FileChooserActivity.this,sdcardList); listPopupWindow.setAdapter(sdCardAdapter); listPopupWindow.setWidth(sdCardAdapter.getItemViewWidth()); //listPopupWindow.setAdapter(new ArrayAdapter&lt;String&gt;(FileChooserActivity.this,android.R.layout.simple_list_item_1,sdcards)); listPopupWindow.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { if(tourController!=null) tourController.switchSdCard(position); if(adapter!=null) { adapter.setData(tourController.getCurrenFileInfoList()); adapter.notifyDataSetChanged(); } if(currentFileAdapter!=null) { currentFileAdapter.setData(tourController.getCurrentFolderList()); currentFileAdapter.notifyDataSetChanged(); } listPopupWindow.dismiss(); } }); listPopupWindow.show(); } }); } @Override public void clickMore() { } @Override public void clickRightText() { if(tourController != null) mChoosenFilePath = tourController.getCurrentFile().getAbsolutePath(); if(this.mFileChooser != null) mFileChooser.finish(mChoosenFilePath); finish(); } @Override protected void onDestroy() { super.onDestroy(); mFileChooser = null; System.out.println(&quot;FileChooserActivity.onDestroy&quot;); } @Override public void onBackPressed() { if(!tourController.isRootFile()) { List&lt;FileInfo&gt; currentList = tourController.backToParent(); adapter.setData(currentList); adapter.notifyDataSetChanged(); currentFileAdapter.setData(tourController.getCurrentFolderList()); currentFileAdapter.notifyDataSetChanged(); } else { super.onBackPressed(); } } } FileTourController.javapackage com.capton.fc; import android.content.Context; import android.os.storage.StorageManager; import java.io.File; import java.lang.reflect.Array; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.ArrayList; import java.util.List; /** * Created by capton on 2018/1/6. */ public class FileTourController { private File currentFile; private File rootFile; private File sdcard0Root; private File sdcard1Root; private List&lt;FileInfo&gt; currenFileInfoList; private List&lt;File&gt; currentFolderList = new ArrayList&lt;&gt;(); private boolean isRootFile = true; private boolean showFile = true; private int sdcardIndex; private Context mContext; public FileTourController(Context context,String currentPath){ //try { this.currentFile = new File(currentPath); //}catch (Exception e){ // e.printStackTrace(); //} this.mContext = context; rootFile = getRootFile(); System.out.println(&quot;FileTourController.getRootFile &quot; + rootFile.getAbsolutePath()); if(currentFile == null) { this.currentFile = rootFile; } else if(!currentFile.exists()) { this.currentFile = rootFile; } else isRootFile = false; if(!currentFile.getAbsolutePath().equals(getRootFile().getAbsolutePath())){ currentFolderList.add(rootFile); ArrayList&lt;File&gt; fileList = new ArrayList&lt;&gt;(); File tempFile = currentFile; while (!tempFile.getParent().equals(rootFile.getAbsolutePath())){ fileList.add(tempFile.getParentFile()); tempFile = tempFile.getParentFile(); } for (int i = fileList.size()-1; i &gt;= 0 ; i--) { currentFolderList.add(fileList.get(i)); } } currenFileInfoList = searchFile(this.currentFile); currentFolderList.add(this.currentFile); } public FileTourController(Context context){ this.mContext = context; rootFile = getRootFile(); this.currentFile = rootFile; currenFileInfoList = searchFile(this.currentFile); currentFolderList.add(this.currentFile); } public boolean isShowFile() { return showFile; } public void setShowFile(boolean showFile) { this.showFile = showFile; } public List&lt;File&gt; getCurrentFolderList() { return currentFolderList; } public List&lt;FileInfo&gt; getCurrenFileInfoList() { return currenFileInfoList; } public File getRootFile(){ if(sdcardIndex == 1){ return getSDcard1(); } else { return getSDcard0(); } } public void switchSdCard(int sdcardIndex){ if(sdcardIndex == 0){ rootFile = getSDcard0(); } else { rootFile = getSDcard1(); } this.currentFile = rootFile; currenFileInfoList = new ArrayList&lt;&gt;(); currentFolderList = new ArrayList&lt;&gt;(); currenFileInfoList = searchFile(this.currentFile); currentFolderList.add(this.currentFile); } public File getSDcard0(){ return new File(getStoragePath(mContext,false)); } public File getSDcard1(){ if(getStoragePath(mContext,true) == null) return new File(getStoragePath(mContext,false)); return new File(getStoragePath(mContext,true)); } public static String getStoragePath(Context mContext, boolean is_removale) { StorageManager mStorageManager = (StorageManager) mContext.getSystemService(Context.STORAGE_SERVICE); Class&lt;?&gt; storageVolumeClazz = null; try { storageVolumeClazz = Class.forName(&quot;android.os.storage.StorageVolume&quot;); Method getVolumeList = mStorageManager.getClass().getMethod(&quot;getVolumeList&quot;); Method getPath = storageVolumeClazz.getMethod(&quot;getPath&quot;); Method isRemovable = storageVolumeClazz.getMethod(&quot;isRemovable&quot;); Object result = getVolumeList.invoke(mStorageManager); final int length = Array.getLength(result); for (int i = 0; i &lt; length; i++) { Object storageVolumeElement = Array.get(result, i); String path = (String) getPath.invoke(storageVolumeElement); boolean removable = (Boolean) isRemovable.invoke(storageVolumeElement); if (is_removale == removable) { return path; } } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } return null; } public boolean isRootFile() { if(isRootFile(currentFile)) isRootFile = true; else isRootFile = false; return isRootFile; } public void setCurrentFile(File currentFile){ this.currentFile = currentFile; } public File getCurrentFile() { return currentFile; } public List&lt;FileInfo&gt; addCurrentFile(File file){ List&lt;FileInfo&gt; fileInfoList = new ArrayList&lt;&gt;(); currentFile = file; currentFolderList.add(file); fileInfoList = searchFile(file); this.currenFileInfoList = fileInfoList; return fileInfoList; } public List&lt;FileInfo&gt; resetCurrentFile(int position){ List&lt;FileInfo&gt; fileInfoList = new ArrayList&lt;&gt;(); while ( currentFolderList.size()-1 &gt; position){ currentFolderList.remove(currentFolderList.size()-1); } if(currentFolderList.size() != 0) currentFile = new File(currentFolderList.get(currentFolderList.size()-1).getAbsolutePath()); else currentFile = rootFile; fileInfoList = searchFile(currentFile); this.currenFileInfoList = fileInfoList; return fileInfoList; } public List&lt;FileInfo&gt; searchFile(File file){ this.currentFile = file; List&lt;FileInfo&gt; fileInfoList = new ArrayList&lt;&gt;(); File childFiles[] = file.listFiles(); if(childFiles != null ) for (int i = 0; i &lt; childFiles.length; i++) { FileInfo fileInfo = new FileInfo(); fileInfo.setFileName(childFiles[i].getName()); fileInfo.setFilePath(childFiles[i].getAbsolutePath()); if(childFiles[i].isDirectory()){ fileInfo.setFolder(true); fileInfo.setFileType(FileInfo.FILE_TYPE_FOLDER); } else { fileInfo.setFolder(false); if(&quot;mp4&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;mkv&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;avi&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;3gp&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;mov&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_VIDEO); else if(&quot;mp3&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;aac&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;amr&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;ogg&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;wma&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;wav&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;flac&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))|| &quot;ape&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_AUDIO); else if(&quot;apk&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_APK); else if(&quot;zip&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_ZIP); else if(&quot;rar&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_RAR); else if(&quot;jpeg&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_JPEG); else if(&quot;jpg&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_JPG); else if(&quot;png&quot;.equals(getFileTypeName(childFiles[i].getAbsolutePath()))) fileInfo.setFileType(FileInfo.FILE_TYPE_PNG); else fileInfo.setFileType(FileInfo.FILE_TYPE_FILE); } if(this.showFile) { fileInfoList.add(fileInfo); }else { if (fileInfo.isFolder()) fileInfoList.add(fileInfo); } } return fileInfoList; } public List&lt;FileInfo&gt; backToParent(){ currentFile = currentFile.getParentFile(); if(isRootFile(currentFile)) isRootFile = true; else isRootFile = false; currentFolderList.remove(currentFolderList.size()-1); // if(tourListener != null) // tourListener.onBackWard(currentFile,isRootFile); return resetCurrentFile(currentFolderList.size()); } public boolean isRootFile(File file){ return rootFile.getAbsolutePath().equals(file.getAbsolutePath()); } private String getParentName(String path){ int end = path.lastIndexOf(&quot;/&quot;) + 1; return path.substring(0,end); } private String getFileTypeName(String path){ int start = path.lastIndexOf(&quot;.&quot;) + 1; if(start == -1) return &quot;&quot;; return path.substring(start); } /* public void setTourListener(TourListener tourListener) { this.tourListener = tourListener; } private TourListener tourListener; public interface TourListener{ void onBackWard(File file,boolean isRootFile); }*/ } 后续感觉还可以继续完善，后续我会把UI框架独立出来单独配置，这样就能自由地控制视觉效果了。本来打算做出对话框形式的，但是想到文件数量多的情况会显示不友好，就先用Activity来展示了，今后会添加一个底部弹出框的形式来显示文件列表，就像我上一个项目BottomDialog的效果那样 https://github.com/Ccapton/BottomDialog好吧，谢谢各位捧场，希望能有前辈们指出我代码的不足之处。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android</tag>
        <tag>个人作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android端二维码生成器]]></title>
    <url>%2F2017%2F09%2F06%2Fqrcode%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn 除了普通的文本链接，还可以将电子名片生成为二维码图片。 这个程序没有任何广告、没有任何恶意插件、病毒，生成过程不依赖网络，请放心使用。 下载链接http://git.oschina.net/ccapton/Files/raw/master/Qr%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8.apk]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android</tag>
        <tag>个人作品</tag>
        <tag>软件分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD风格Mvp—RxJava2应用，MVP初体验]]></title>
    <url>%2F2017%2F09%2F05%2Fmvp_rxjava_md%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn 项目地址https://github.com/Ccapton/Mvp-RxJava2Demo apk:http://git.oschina.net/ccapton/Files/raw/master/ccapton_mvp.apk 波尼音乐Githubdi地址https://github.com/wangchenyan/PonyMusic 之前，我写android代码涉及到数据与视图关系时，都是直接将数据加载到视图中，例如在RecyclerView.Adapter中的onBindViewHolder方法中例如: @Override public void onBindViewHolder(ViewHolder holder, int position) { TextView titleTv=((TextView)holder.itemView.findViewById(R.id.titleTv)); titleTv.setText(articleList.get(position)); } articleList 为通过网络获取解析后得到的Article集合。通过上面的代码可以看到，articleList是个全局变量，要么在RecyclerView.Adapter子类中，要么在Activity、Fragment中。这样的话如果要修改articleList中的数据，势必在Activity、Fragment或是RecyclerView.Adapter子类中操作，一两个数据集合不见得多几行代码，要是有4-5个或者更多呢？这样这些“容器”肯定会臃肿的非常厉害。这时就要对数据、视图与逻辑控制进行业务分离，即数据层、视图层与控制层要明确各种的工作，要做到分工明确又合作通畅。于是MVC与MVP模式便是我们整理代码逻辑的重要方式。关于MVC这里就不多说了，我直接来谈它的进化版MVP。 我通过阅读一篇文章 http://www.jianshu.com/p/9a6845b26856/ 对MVP模式有了一些理解。下面这段总结是精华 在MVP模式里通常包含4个要素：(1) View :负责绘制UI元素、与用户进行交互(在Android中体现为Activity);(2) View interface :需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;(3) Model :负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合);(4) Presenter :作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。 用我的话总结起来，MVP最重要的点：是实现数据（Model）与视图（View）的分离。在构建好MVP代码后，通常情况我们1、先需要在Activity（Fragment）中实现View接口（此View非彼View），将其泛型设置为对应的Presenter，实现其抽象方法；例如： 、、、 public class MainActivity extends BaseActivity implements IView&lt;ArticlePresenter&gt;,View.OnClickListener 、、、 2、然后新建Presenter子类对象（View作为参数），通过Presenter内定义的方法将Bean数据（例如：Article对象）加载到数据层（Model）中，并将数据加载到视图层（View）中；例如在RecyclerView.Adapter中的onBindViewHolder方法中 @Override public void onBindViewHolder(ViewHolder holder, int position) { ArticlePresenter presenter=new ArticlePresenter(MainActivity.this); presenter.saveData(articles.get(position)); presenter.setDataOnView(holder.itemView); } 3、然后在第一步实现的抽象方法中，通过Presenter进行具体的视图（View）加载数据（Model）操作；例如： @Override public void setDataOnView(final ArticlePresenter presenter, View view) { TextView view1= (TextView) view.findViewById(R.id.title); TextView view2= (TextView) view.findViewById(R.id.author); TextView view3= (TextView) view.findViewById(R.id.date); view1.setText(((Article)presenter.getData()).getTitle()); view2.setText(((Article)presenter.getData()).getAuthor()); view3.setText(((Article)presenter.getData()).getDate()); RelativeLayout article_item = (RelativeLayout) view.findViewById(R.id.article_item); article_item.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startActivity(WebActivity.class,((Article)presenter.getData()).getId()); } }); } 以上是我的MVP调用代码，看似比之前直接将数据设置到视图中代码量多是吧。但将数据操作的大量代码封装进了Model层中，Presenter就可以直接调用达到修改数据的目的，就可以在Activity中省下一大段代码了。 说了那么多，还有朋友不知道怎么写MVP代码，这是一个既简单又有点恶心的步骤，下面是我为这个应用写的MVP代码，虽然没有封装其他数据操作的方法，但是对于理解MVP来说够用了吧。首先是两个接口（IView、IModel）和一个抽象类IPresenterIView.java public interface IView&lt;IPresenter&gt;{ /** * 等待Present调用的方法，子类（例如Activity，Fragment）实现其具体代码 * @param iPresenter 返回的iPresenter本体对象 * @param view 你要加载的具体视图；例如在RecyclerView中， * onBindViewHolder方法里的viewHolder.itemView; */ void setDataOnView(IPresenter iPresenter,View view); } IModel.java public interface IModel{ /** * 设置Bean数据 * @param object */ void set(Object object); /** * 获取Bean数据 * @return */ Object get(); } IPresenter.java public abstract class IPresenter{ IView&lt;IPresenter&gt; iView; //Activity，Fragment实现此接口，等待IPresenter子类对象 回调 setDataOnView()方法 IModel iModel; //数据模型，不暴露给Activity，Fragment等IView子类 /** * 以IView子类作为参数的构造函数 * @param iView 例如，Activity.this */ public IPresenter(IView&lt;IPresenter&gt; iView){ this.iView=iView; } /** * 传入view，IPresenter子类将从Model层中获取Bean数据，再加载到view中（用于ListView,RecycerView等列表视图） * @param view */ public abstract void setDataOnView(View view); /** * 设置Bean数据到Model层的IModel子类中去 * @param object Bean数据对象，例如Article对象 */ public abstract void saveData(Object object); /** * 从Model层获取Bean数据 * @return */ public abstract Object getData(); } 接下来是上面三个父类的具体实现子类 Activity、ArticleModel、 ArticlePresenterAcitivity只需要实现IView接口即可，并实现其抽象方法。上面已经给出了代码 ArticleModel.java public class ArticleModel implements IModel { private Article mArticle=new Article(); @Override public void set(Object object) { mArticle= (Article) object; } @Override public Object get() { return mArticle; } } ArticlePresenter.java public class ArticlePresenter extends IPresenter{ public ArticlePresenter(IView iView){ super(iView); this.iModel=new ArticleModel(); } @Override public void setDataOnView(View view) { iView.setDataOnView(ArticlePresenter.this,view); } @Override public void saveData(Object object) { iModel.set(object); } @Override public Object getData() { return this.iModel.get(); } } 通过上面代码可以看出，ArticlePresenter实现了父类的saveData(Object object)，setData(Objec object)和getData()方法。 getData()：从IModel子类(ArticleModel)对象中返回具体的数据 saveData(Object object)：通过IModel子类(ArticleModel)对象iModel的set(object)方法将数据存入Model中，等待调用。 setData(Objec object)：通过Activity(IView子类)对象iView的setDataOnView(ArticlePresenter.this,view)操作,将数据加载到视图中。 至此，我对于MVP模式的理解到此为止，欢迎朋友们与我交流探讨！ 下面是这个Demo用到的各种库与框架： compile &#39;com.android.support:design:25.3.1&#39; compile &#39;com.lapism:searchview:5.0.0-alpha4&#39; compile &#39;com.scwang.smartrefresh:SmartRefreshLayout:1.0.3&#39; compile &#39;com.scwang.smartrefresh:SmartRefreshHeader:1.0.3&#39; compile &#39;de.hdodenhof:circleimageview:2.1.0&#39; compile &#39;me.xiaopan:sketch:2.4.1&#39; compile &#39;online.osslab:CircleProgress:1.0.0&#39; compile &#39;com.github.Ccapton:Android-ColorfulProgressBar:1.0.5&#39; compile &#39;cn.hugeterry.coordinatortablayout:coordinatortablayout:1.1.0&#39; compile &#39;com.jakewharton:butterknife:8.8.1&#39; annotationProcessor &#39;com.jakewharton:butterknife-compiler:8.8.1&#39; compile &#39;io.reactivex.rxjava2:rxandroid:2.0.1&#39; compile &#39;io.reactivex.rxjava2:rxjava:2.1.3&#39; compile &#39;com.squareup.okhttp3:okhttp:3.8.1&#39; compile &#39;com.github.bumptech.glide:glide:3.8.0&#39; annotationProcessor &#39;com.github.bumptech.glide:compiler:4.0.0&#39; compile &#39;com.just.agentweb:agentweb:2.0.0&#39; compile &#39;com.blankj:utilcode:1.8.5&#39; 欢迎大家来踩我的Github https://github.com/ccapton 、博客 http://ccapton.cn]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android</tag>
        <tag>个人作品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java技术:Gif编码器(gifencoder)的实际应用(2)]]></title>
    <url>%2F2017%2F08%2F27%2FJava_Technology_2%2F</url>
    <content type="text"><![CDATA[关于我，欢迎关注csdn博客：ccapton(http://blog.csdn.net/ccapton) 微信：CcaptonGithub: (https://www.github.com/ccapton)个人博客:http://www.ccapton.cn Gif合成软件： 结合前几天的gif合成框架，我用Java的swing界面编程完成了这款Gif合成软件： https://pan.baidu.com/s/1slfUkcH若前面的面链接失效，请点这里https://raw.githubusercontent.com/Ccapton/FileRepertory/master/files/GifMaker.jar 它能将若干张静态图片连接成gif图片。 mac下的效果： 输出的gif图片： 这是我将几张系统自带壁纸合成gif的过程，就不贴效果了。 在Mac下，Jar文件打开的过程中，初次生成Swing界面耗时比较长，要等10s左右；在Windows平台下则是秒开。 目前这个程序的算法只支持若干张同等尺寸的图片合成gif，而且每张图片中最好不要有透明度为0的像素点，即选取的图片要等宽等高，而且图片最好不要有透明的部分，否则透明的部分会被白色填充、或者直接合成失败。 由于gifencoder提供的api只有GifEncoder这个类，所以也没办法，功能比较单一，这个框架是square开发组织两年前的作品了，上次更新代码是9个月前，所以近期不太会有更新了，大家就随便看看吧。gifencoder框架地址 https://github.com/square/gifencoder]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>个人作品</tag>
        <tag>Java技术</tag>
        <tag>Gif</tag>
        <tag>Gif制作软件</tag>
        <tag>图片处理技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java技术:Gif编码器(gifencoder)的实际应用(1)]]></title>
    <url>%2F2017%2F08%2F22%2FJava_Technology_1%2F</url>
    <content type="text"><![CDATA[Gif编码器 gifencoder gifencoder 这是一个Java写的图片转Gif的框架 https://github.com/square/gifencoder 本来想搜一下视频转Gif的相关框架的，找到了一个用JavaScript写 https://github.com/vvo/gifify ，但是 我在安装其配置需求 ImageMagick 时发现 用命令$ brew install imagemagick –with-fontconfig时，安装到最后总是卡住了，去掉–with-fontconfig安装倒是能装进去，可是最后代码运行时又提醒我需要设置ImageMagick，弄来弄去还是没成功-_-!。于是便找到了图片转Gif的gifencoder这个框架 gifencoder用法 这是gifencoder的Github页上的基础用法 有关问题 但是没有交代清楚存放图片rgb颜色数据的二维整形数组该怎么获取， 在Android上，好像并没有直接获得二维数据的方法。于是我尝试了用Bitmap的copyPixelsToBuffer()方法获取一维数组，如下所示 public int[] convertImageToArray(File file) { Bitmap bitmap= BitmapFactory.decodeFile(file.getAbsolutePath()); int rgbArray[]=new int[bitmap.getAllocationByteCount()]; Buffer buffer=IntBuffer.wrap(rgbArray); bitmap.copyPixelsToBuffer(buffer); bitmap.recycle(); return rgbArray; } 然后调用GifEncoder的另一个addImage方法 /** * Add an image to the GIF file. * * @param rgbData an image buffer in RGB format * @param width the number of pixels per row in the pixel array * @param options options to be applied to this image * @return this instance for chaining * @throws IOException if there was a problem writing to the given output stream */ public GifEncoder addImage(int[] rgbData, int width, ImageOptions options) throws IOException { addImage(Image.fromRgb(rgbData, width), options); return this; } 可是当我跑起来时，不知道是不是因为参数不正确还是咋地，怎么修改都会出现手机内存吃紧”Starting a blocking GC Alloc”，最后强制退出的问题，输出的gif图片也是只有1kb，即转换失败了，我觉得一开始获取一维数组的时候出现问题了，导致后面数据处理时间太长了。后来我还是放弃了gitencoder在Android上的应用了,果断选择在桌面端Java平台上继续试。 桌面端Java使用gitencoder我使用的是IntelliJ IDEA,直接下载jar包，引入java工程内,我使用这个框架的代码就下面这么点，就能输出想要的gif图片 import com.squareup.gifencoder.GifEncoder; import com.squareup.gifencoder.ImageOptions; import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.*; public class Main { public static void main(String[] args) { // 读取图片到BufferedImage BufferedImage bf = readImage("/Users/capton/Desktop/apple1.png");//这里写你要读取的绝对路径+文件名 BufferedImage bf2 = readImage("/Users/capton/Desktop/apple2.png");//这里写你要读取的绝对路径+文件名 BufferedImage bf3 = readImage("/Users/capton/Desktop/apple3.png");//这里写你要读取的绝对路径+文件名 BufferedImage bf4 = readImage("/Users/capton/Desktop/apple4.png");//这里写你要读取的绝对路径+文件名 BufferedImage bf5 = readImage("/Users/capton/Desktop/apple5.png");//这里写你要读取的绝对路径+文件名 // 将图片转换为二维数组 int[][] rgbArray1 = convertImageToArray(bf); int[][] rgbArray2= convertImageToArray(bf2); int[][] rgbArray3= convertImageToArray(bf3); int[][] rgbArray4= convertImageToArray(bf4); int[][] rgbArray5= convertImageToArray(bf5); OutputStream outputStream = null; try { outputStream = new FileOutputStream("/Users/capton/Desktop/apple.gif"); ImageOptions options = new ImageOptions(); GifEncoder encoder=new GifEncoder(outputStream, 161, 182, 0); encoder.addImage(rgbArray1, options); encoder.addImage(rgbArray2, options); encoder.addImage(rgbArray3, options); encoder.addImage(rgbArray4, options); encoder.addImage(rgbArray5, options); encoder.finishEncoding(); } catch (FileNotFoundException e) { e.printStackTrace(); }catch (IOException e){ e.printStackTrace(); } finally{ try { outputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } public static BufferedImage readImage(String imageFile){ File file = new File(imageFile); BufferedImage bf = null; try { bf = ImageIO.read(file); } catch (IOException e) { e.printStackTrace(); } return bf; } public static int[][] convertImageToArray(BufferedImage bf) { // 获取图片宽度和高度 int width = bf.getWidth(); int height = bf.getHeight(); // 将图片sRGB数据写入一维数组 int[] data = new int[width*height]; bf.getRGB(0, 0, width, height, data, 0, width); // 将一维数组转换为为二维数组 int[][] rgbArray = new int[height][width]; for(int i = 0; i < height; i++) for(int j = 0; j < width; j++) rgbArray[i][j] = data[i*width + j]; return rgbArray; } } 其中’ GifEncoder encoder=new GifEncoder(outputStream, 161, 182, 0);’这里161，182是图片的宽高(px),我们要把每一张图片的宽高都统一，然后把宽高通过这句代码设置完毕 5张不同方向黑白渐变的苹果logo，把它们整合成gif后，就出现下面的效果了 后记这里使用了BufferImage这个类，它是基于java的AWT控件的，而Android上并不支持AWT，于是也就不能用BufferImage了，之前我的方法又不对。所以请问大家，有谁知道怎么在Android上使用这个gifencoder框架的吗？在这之后，我打算仔细研究一些这个框架，用AWT把它做出图像界面来，这样方便大家使用这样一个java版的图片转Gif软件可好？]]></content>
      <categories>
        <category>Java技术</category>
      </categories>
      <tags>
        <tag>Java技术</tag>
        <tag>Gif</tag>
        <tag>图片处理技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自制简易音乐播放器（未完成）数据来源：QQ音乐]]></title>
    <url>%2F2017%2F08%2F20%2Fmusic%2F</url>
    <content type="text"><![CDATA[数据源本来只想重新练练RecyclerView的，一不小心又弄得复杂了。。。 无意中想起来搞个网络音乐播放器，本地的就算了，目前没时间去仔细弄了，但是这个没有多深入的逻辑控制，只是简单的播放逻辑，这也是很折磨人啊，大家看看就好了。于是上网搜了一下免费的音乐api，误打误撞找到一个用Java写的几个国内音乐搜索（QQ音乐，酷狗，虾米，网易云音乐）接口 https://github.com/Qrilee/MusicuuApi 请直接拷贝代码到你的工程里去，jar包也直接拷到libs下。 其中网易云好像被封了，访问不了，反正经过我的测试返回404信息。 在WyMusic、NetUtil类中，导入的sun.misc.BASE64Encoder 这个工具类必须换为 android.util.Base64，因为android中没有BASE64Encoder，取而代之的是Base64。其中的方法也按要需求调用，WyMusic.java中，我是这样使用的 String retval = Base64.encodeToString(md5Bytes,Base64.DEFAULT); Base64工具类使用位置 WyMusic这个是网易云音乐的类，还有NetUtil类中也用到了Base64工具类，如果你想用的话请注意这点哟。 效果图好吧，直接看我写的播放器效果吧。 搜索页面。这个程序有一些bug，不过也没关系啦，能听就行，后台也不会挂掉有一些图标是自己画的，你们看得出来吗？好吧，肯定看不出来。啦啦啦。播放控件中的播放顺序四个模式的图标和右边的播放列表图标是我用AI画的，实在是觉得网上的图标太丑了，颜色还要自己调，不如直接用AI画出来，简单的线条UI还是能弄出来的 搜索页面，时间很长，这不怪我-_-！好吧搜索时间长也是这个搜索接口的原因，可能数据早已经通过网络获取到了，但解析时间过长吧，看原作者的后续更新吧。还有歌词的功能，这里就没去弄了，毕竟不是专业的播放器。我特别喜欢网易云音乐，可惜用这个接口目前我弄不到它的数据，网上其他方法我也找过了，几乎都是同一个方法（POST方式，添加请求头参数），这个也不例外，被服务拒绝了还是地址换了？有谁知道的吗 这是下拉菜单中的前台Notification,与音乐控制器关联着，音乐播放与界面刷新逻辑关系搞得我头大呀感觉移动端的逻辑问题很难缠，页面效果实现相比之下就了，现在那么多成熟又漂亮的第三方视图和动画，我们只需要稍微修改就能满足开发需求吧。 新闻模块，用的是极速数据提供的接口由于新闻数据api的数据有限，不像今日头条、新浪新闻等专业大户有海量数据，由于这里只是业余的程序，只需要刷出来固定的十几条最新数据就行了。 这是新闻的搜索页，也是挺长时间的，也不怪我好吗-_-?这些都是自己一字一句码出来效果，界面效果不是问题，就是逻辑关系搞得很蛋疼☹️。本来还好的Fragment，越来越臃肿，多少行代码我就不说了，简直扎心了，还好我的MainActivity，只有不到100行。因为MainActivity只管着几个Fragment的切换功能，作为Fragment的容器，几乎没有耗时的代码。 文件结构有点乱，这不是重点，毕竟只有这么十几个Java文件，要做大事的时候肯定要归类好代码文件看官们觉得咋样？没有用DataBinding这些东西，虽然早就听闻了，一看还有点难度，就放着了，以后肯定会用上的吧(现在有更好用的ButterKnife了，以后就用它了)。 令我满意的是播放顺序这块的逻辑没毛病，其他的东西就随便看看吧，哈哈。其中加载动画和播放进度条用是自己写的控件，Seekbar本来也是用自己的，后来出现bug了，不想浪费时间就用原生的了。代码有点杂乱，我就不贴了。这里给个安装包大家瞧瞧就行了， https://github.com/Ccapton/EasyPlayer/blob/master/%E4%B8%AA%E6%80%A7%E5%8C%96.apk 至于JNI开发，我还没怎么去接触诶，似乎都是要在移动端高效运行的程序才要？比如直播类等软件需要高效压缩摄像头采集的数据的算法，这就需要更接近底层的C与C++才能做到；还有大名鼎鼎的视频处理项目FFmpeg，本来在桌面端的项目，用于Android移动端简直不要太变态，很多播放器就用到了它的代码吧。需要保密的程序算法，要用到打包的so库来防止被反编译。 好了，这篇文章就到这了，主要是自己写了这么一个功能单一程序，实际对大家有用的东西估计就是下面的链接了。那么下期见。 用到的一些库、框架音乐数据源 MusicuuApi：https://github.com/Qrilee/MusicuuApi 图片加载 Glide：https://github.com/bumptech/glide 数据解析 Gson：https://github.com/google/gson 网络通信 Volley ：https://github.com/mcxiaoke/android-volley 网络通信 Okhttp：https://github.com/square/okhttp 浏览器控件 AgentWeb：https://github.com/Justson/AgentWeb 上下拉刷新控件 SmartRefreshLayout: https://github.com/scwang90/SmartRefreshLayout 左右滑动删除列表项控件 Swipemenulistview: https://github.com/baoyongzhang/SwipeMenuListView 选项拖拽控件DragGridView：https://github.com/zhaoyu87/DragGridView（用在新闻频道的选择页里） Activity滑动退出控件 SwipeBackLayout：https://github.com/ikew0ng/SwipeBackLayout （用在了新闻浏览页上） 搜索等待动画 SLView （自己写的☺）：https://github.com/Ccapton/Android-SLView 播放进度条ColorfulProgressbar（自己写的☺）: https://github.com/Ccapton/Android-ColorfulProgressBar 关于作者我的Github：https://github.com/Ccapton/ 欢迎来踩!]]></content>
      <categories>
        <category>Android个人作品</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android应用</tag>
        <tag>个人作品</tag>
        <tag>音乐播放器</tag>
        <tag>QQ音乐</tag>
        <tag>酷狗音乐</tag>
        <tag>网易云音乐</tag>
        <tag>虾米音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View之-ColorfulSeekbar]]></title>
    <url>%2F2017%2F08%2F18%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B-ColorfulSeekbar%2F</url>
    <content type="text"><![CDATA[Android-ColorfulSeekbar 关于我，欢迎关注 博客：ccapton(http://blog.csdn.net/ccapton) 微信：Ccapton Github: (https://www.github.com/ccapton) ColorfulSeekbar这个控件是我根据前作ColorfulProgressbar https://github.com/Ccapton/Android-ColorfulProgressBar变化而来的，进度条与之相比没有变化，功能与原生Seekbar没差别。 具体用法与ColorfulProgressbar类似，这里不再赘述。 demo下载： https://raw.githubusercontent.com/Ccapton/Android-ColorfulSeekbar/master/ColorfulSeekbarDemo.apk 如何配置build.gradle(Project) allprojects { repositories { ... maven { url 'https://jitpack.io' } } } build.gradle(Module:app) dependencies { compile 'com.github.Ccapton:Android-ColorfulSeekbar:1.0' }]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android</tag>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义View之-ColorfulProgressbar]]></title>
    <url>%2F2017%2F08%2F14%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B-ColorfulProgressbar%2F</url>
    <content type="text"><![CDATA[Android-ColorfulProgressBar 关于我，欢迎关注 博客：ccapton(http://blog.csdn.net/ccapton) 微信：Ccapton Github: (https://www.github.com/ccapton) 简介:这是一个自定义的Progressbar，效果看着还行吧，滚动的双色斜条作为进度条，有点类似Bootstrap风格。原生Progress的基本操作都有，自行观摩我的源码吧，挺简单的。 示例: 演示Demo当前是修改了视图的版本，如下图所示，第二进度条似乎更加立体了，它像是被镶嵌在了主控件中 demo下载：https://github.com/Ccapton/Android-ColorfulProgressBar/blob/master/ColorfulProgressBarDemo_1_0_3.apk 特性与原生Progress相比，感觉更漂亮一点，可以显示进度值，背景凹凸感明显，进度条效果更加立体。 原理说明额，挺简单的。不过感觉我的做法有点复杂了，我先自定义了一个View，专门作为进度条的显示图层,如下所示 然后将其布局在高度不超过20dp的ColorfulProgressBar父布局中，设置Y方向的偏移量，然后动画循环改变Y坐标，实现斜条滚动的动画效果，当你调用setProgress方法时，则改变其在父布局的X坐标实现进度显示的功能，进度文字同样原理添加到了父布局中。 如何配置build.gradle(Project) allprojects { repositories { ... maven { url 'https://jitpack.io' } } } build.gradle(Module:app) dependencies { compile 'com.github.Ccapton:Android-ColorfulProgressBar:1.0.5' } 主要方法 setStyle(String style) // ColofulProgressBar.STYLE_NORMAL、 ColofulProgressBar.STYLE_COLORFUL两种风格 setMaxProgress(long maxProgress) // 设置进度最大值 setProgress(long progress); //设置当前进度 setSecondProgress(long secondProgress); //设置第二进度 setAnimation(false); // 关闭动画 showPercentText(false); //隐藏进度文字 setHeight(int height); // 设置整个控件高度 setWidth(int width); // 设置整个控件宽度 setProgressColorRes(int progressColorRes); // 设置进度条颜色一 setProgressColor2Res(int progressColor2Res) // 设置进度条颜色二 setPercentColorRes(int percentColorRes); //设置进度文字的颜色 setPercentShaderColorRes(int percentShadeColorRes); //设置进度文字的阴影颜色 setBackgroundColorRes(int backgroundColorRes) //设置控件背景色 使用方法例：在activity_main.xml中， 这是普通效果的Progressbar &lt;com.capton.colorfulprogressbar.ColorfulProgressbar android:id="@+id/colorfulProgressbar" xmlns:app="http://schemas.android.com/apk/res-auto" app:style="@string/style_normal" app:max="100" app:progress="50" app:secondProgress="10" app:progressColor1="@color/green" android:layout_marginTop="16dp" android:layout_width="match_parent" android:layout_height="wrap_content" > 这是双色的Progressbar &lt;com.capton.colorfulprogressbar.ColorfulProgressbar android:id="@+id/colorfulProgressbar2" xmlns:app="http://schemas.android.com/apk/res-auto" app:style="@string/style_colorful" app:max="100" app:progress="50" app:secondProgress="10" app:progressColor1="@color/green" app:progressColor2="@color/orange" android:layout_marginTop="16dp" android:layout_width="match_parent" android:layout_height="wrap_content" > 例：在MainActivity中 ColorfulProgressbar progressbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); progressbar= (ColorfulProgressbar) findViewById(R.id.colorfulProgressbar); progressbar.setMaxProgress(100); progressbar.setProgress(50); // progressbar.setSecondProgress(10); // progressbar.setAnimation(false); 关闭动画 // progressbar.showPercentText(false); 隐藏进度文字 } 作者的话 挺漂亮的ProgressBar，就是没啥技术含量。。。。具体需求大家自己随便研究琢磨]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android</tag>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件分享-（Mac端）IntelliJ_IDEA_2017破解版]]></title>
    <url>%2F2017%2F05%2F10%2F%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB-%EF%BC%88Mac%E7%AB%AF%EF%BC%89IntelliJ-IDEA-2017%E7%A0%B4%E8%A7%A3%E7%89%88%2F</url>
    <content type="text"><![CDATA[下载IntelliJ IDEA 2017与JetbrainsCrack-2.6.2.jarJetbrainsCrack-2.6.2.jar 链接:http://pan.baidu.com/s/1eRJkOcq 密码:a4ji IntelliJ IDEA 2017版本 链接:http://pan.baidu.com/s/1kVHoZ5t 密码:weu3 找到IntelliJ IDEA，右键显示包内容，将JetbrainsCrack-2.6.2.jar复制到Contents/bin目录下 继续打开Contents/bin目录下目录下idea.vmoptions文件，在文件末尾追加上：-javaagent:JetbrainsCrack-2.6.2.jar 打开运行IntelliJ IDEA，Help-&gt;Register输入一下Code即可激活。{ "licenseId": "ThisCrackLicenseId", "licenseeName": "你的名字", "assigneeName": "", "assigneeEmail": "你的邮箱", "licenseRestriction": "Only Test! Please support genuine!!!", "checkConcurrentUse": false, "products": [ { "code": "II", "paidUpTo": "2099-12-31" }, { "code": "DM", "paidUpTo": "2099-12-31" }, { "code": "AC", "paidUpTo": "2099-12-31" }, { "code": "RS0", "paidUpTo": "2099-12-31" }, { "code": "WS", "paidUpTo": "2099-12-31" }, { "code": "DPN", "paidUpTo": "2099-12-31" }, { "code": "RC", "paidUpTo": "2099-12-31" }, { "code": "PS", "paidUpTo": "2099-12-31" }, { "code": "DC", "paidUpTo": "2099-12-31" }, { "code": "RM", "paidUpTo": "2099-12-31" }, { "code": "CL", "paidUpTo": "2099-12-31" }, { "code": "PC", "paidUpTo": "2099-12-31" } ], "hash": "2911276/0", "gracePeriodDays": 7, "autoProlongated": false } 原文链接：http://blog.csdn.net/zhangyong125/article/details/72804282]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>IntelliJ IDEA_2017</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人开发应用《纯粹漫画》]]></title>
    <url>%2F2017%2F05%2F03%2FPureComic%2F</url>
    <content type="text"><![CDATA[概况应用下载页 http://shouji.baidu.com/software/11411328.html 直接扫码下载apk 《纯粹漫画》是我根据前作《纯粹菜谱》改进而来的新作，这次采用了成熟的图片加载框架Glide，网络请求框架Okhttp和数据解析库Fastjson整合而成的漫画 阅读App。 应用介绍《纯粹漫画》的数据同样来自聚合数据，列表采用了更加高效的RecyclerView，配合图片加载框架Glide，使用户在刷新数据的时候更加流畅地浏览漫画信息。这次加入了广告SDK，在用户刷新列表和搜索漫画时便会展示广告。这次加入了用户登录模块，即用户可以注册本应用账号进行登录、数据更新与恢复。 开发历程一想到漫画所需的翻页元素，就想到了ViewPager，然后便通过加载Fragment展示每一页漫画数据的形式表现出来。但是一开始选用的数据适配器是FragmentPagerAdapter，导致ViewPager不能及时销毁产生的大量FragmentPagerAdapter导致手机内存紧张而卡顿。思考许久，一直以为是图片资源没有回收而导致内存泄漏的问题，后来总算想起来了FragmentStatePagerAdapter这个能自动释放Fragment页面资源的适配器。而漫画有时需要看到细节的地方，所以漫画页面要能实现放大缩小的效果，于是便上网找到了ScaleView https://github.com/Ccapton/Android-ScaleView 这个比较实用的自定义View，将其整合到项目中简直完美了。 作者的话希望看到我这片文章的朋友能对我这个纯粹漫画给些意见，谢谢了]]></content>
      <categories>
        <category>Android个人作品</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android应用</tag>
        <tag>个人作品</tag>
        <tag>纯粹漫画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人开发应用《纯粹菜谱》]]></title>
    <url>%2F2017%2F02%2F18%2FPureCooking%2F</url>
    <content type="text"><![CDATA[概况应用下载页 http://www.anzhi.com/soft_2761007.html 扫码下载apk 《纯粹菜谱》是我本着练习异步网络请求，数据解析、数据库操作和云后端Bmob的第一个应用。菜谱数据来自聚合数据（已认证本应用）。 应用介绍这是一款提供各式菜肴做法的app，菜谱五花八门，你想得到的菜肴都可通过关键词搜索到。目前只支持QQ认证登录（QQ空间分享），本来想做微信和微博分享的，但是后来我的电脑不小心卡机了，这个应用的源代码都丢失了，也就懒得去弄了。 开发历程由于是第一个Android项目，并没有用到很多第三方库和框架，所以有很多不成熟和冗余的代码。开发过程中，让我受益最多的是，通过自己的代码实践做到了自己想要的效果，例如在Fragment中添加多个子Fragment，并实现父子Fragment的数据通信。还有就是明白了Android应用上市所经历的各个步骤和细节，毕竟一步一个脚印走了过来，途中的艰辛我相信只有与我志同道合有相同经历的朋友才明白。 作者的话希望看到我这片文章的朋友能对我这个纯粹菜谱给些意见，谢谢了]]></content>
      <categories>
        <category>Android个人作品</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android应用</tag>
        <tag>个人作品</tag>
        <tag>纯粹菜谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[龙珠Z中热血的bgm]]></title>
    <url>%2F2017%2F02%2F10%2Fshare_music2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>音乐分享</category>
      </categories>
      <tags>
        <tag>音乐分享</tag>
        <tag>BGM</tag>
        <tag>龙珠</tag>
        <tag>龙珠Z</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英雄联盟S6全球总决赛 合集]]></title>
    <url>%2F2017%2F01%2F22%2Fshare_music%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>音乐分享</category>
      </categories>
      <tags>
        <tag>音乐分享</tag>
        <tag>英雄联盟</tag>
        <tag>BGM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件分享-（Mac端）DiskKeeper_Pro破解版]]></title>
    <url>%2F2016%2F09%2F10%2F%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB-%EF%BC%88Mac%E7%AB%AF%EF%BC%89DiskKeeper-Pro%E7%A0%B4%E8%A7%A3%E7%89%88%2F</url>
    <content type="text"><![CDATA[下载链接https://github.com/Ccapton/FileRepertory/raw/master/files/DiskKeeper.Pro_1.4.13_20170122.dmg DiskKeeper Pro for mac是Mac平台上的一款磁盘碎片整理软件，Diskeeper Pro for mac只要达到预设的垃圾文件的数值就会触发自动清理功能，不会让用户再时常担心磁盘的垃圾问题。提高用户体验度。 功能特点 从菜单栏启动快速清洗 应用缓存和垃圾数据 浏览器缓存和垃圾（Safari，Firefox，Chrome） 用户日志（保持您的保护和垃圾免费） 电子邮件缓存 垃圾箱 其他功能 DiskKeeper Pro有一个可选的自动清理功能，每次达到预设的垃圾邮件大小阈值时都会触发。还支持可选的通知中心报告，通知您已自动清除的垃圾的大小。 高级但易于使用的集成卸载程序。只需删除或移动应用程序到垃圾桶和DiskKeeper Pro将完全卸载它，删除所有剩菜。 DiskKeeper Pro有一个特殊的“保持我清洁”模式。在这种模式下，它将保留在您的菜单栏，准备删除任何种类的快速清洁垃圾。最先进的先进清洁剂，拥有惊人的用户体验。]]></content>
      <categories>
        <category>软件分享</category>
      </categories>
      <tags>
        <tag>软件分享</tag>
        <tag>DiskKeeper Pro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android技术]]></title>
    <url>%2F2016%2F06%2F18%2FAndroid%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[这是新的篇章，敬请期待]]></content>
      <categories>
        <category>Android开发</category>
      </categories>
      <tags>
        <tag>Android开发</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[这是我的个人博客站，上传一些自己写的android代码和技术文章。偶尔分享一些好用的软件，好听的音乐邮箱：437499914@qq.com 、chenweibin1125@foxmail.com微信：Ccapton]]></content>
  </entry>
  <entry>
    <title><![CDATA[分类]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[board]]></title>
    <url>%2Fboard%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
